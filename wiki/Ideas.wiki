#summary Various ideas, some crazier than others.
#labels Phase-Design

=Abstraction and Modularization=
  * {{{board::heuristic()}}} could be declared virtual to permit alternative versions.
    * Even better, the {{{board}}} class could associate a {{{heuristic}}} class capable of being modified at runtime.
  * {{{search::iterate()}}} could call an abstract method for tree searching.  This would facilitate runtime switching between tactical search methods.  It would also allow anyone to experiment with algorithms other than !NegaScout (like conspiracy number search?) without disturbing the current implementation.
    * Maybe we could go even further and have {{{search::change()}}} call an abstract method?  This way, we could play with alternate iterative deepening strategies.  Also, some tree search methods may not be conducive to iterative deepening.

=Heuristics=
  * A "sub-heuristic" I've played around with is to reward pieces that can capture pieces of their own color.  This promotes good defensive structures, e.g., pawns that protect each other.  It's extremely important to make this sub-heuristic worth less than the lowest material value.  The effect is, if two lines have the same heuristic (material) evaluation, the sub-heuristic (defensive structure) breaks the tie.  This is good for creating opening pawn structure.
    * This is a great idea for pawns but can't be generalized to all pieces.  For example, a bishop trapped behind (defending) two pawns is worthless.  Take a look at the latest revision of [http://gray-matter.googlecode.com/svn/trunk/src/board.cpp the board class], specifically {{{board::evaluate_pawn()}}}.